var searchIndex = {};
searchIndex["lib"] = {"doc":"","items":[[0,"problem","lib","",null,null],[3,"LpProblem","lib::problem","Structure used for creating the model and solving a linear problem.",null,null],[4,"LpObjective","","Enum helping to specify the objective function of the linear problem.",null,null],[13,"Minimize","","",0,null],[13,"Maximize","","",0,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",1,null],[11,"new","","Create a new problem",1,{"inputs":[{"name":"str"},{"name":"lpobjective"}],"output":{"name":"lpproblem"}}],[11,"write_lp","","",1,null],[11,"solve","","Solve the LP model",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[0,"solvers","lib","",null,null],[4,"Solver","lib::solvers","",null,null],[13,"Cbc","","",2,null],[13,"CbcPath","","",2,null],[13,"Gurobi","","",2,null],[13,"GurobiPath","","",2,null],[4,"Status","","",null,null],[13,"Optimal","","",3,null],[13,"SubOptimal","","",3,null],[13,"Infeasible","","",3,null],[13,"Unbounded","","",3,null],[13,"NotSolved","","",3,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",3,null],[11,"fmt","","",3,null],[11,"run_solver","","",2,null],[11,"read_solution","","",2,null],[0,"variables","lib","",null,null],[3,"LpVariable","lib::variables","",null,null],[3,"LpConstraint","","",null,null],[12,"0","","",4,null],[12,"1","","",4,null],[12,"2","","",4,null],[4,"LpType","","Type of variables. Using to initialize a linear programming variable",null,null],[13,"Binary","","Binary variable",5,null],[13,"Integer","","Integer variable",5,null],[13,"Continuous","","Reel variable",5,null],[4,"LpExpression","","ADT for Linear Programming Expression",null,null],[13,"BinaryVariable","","",6,null],[12,"name","lib::variables::LpExpression","",6,null],[13,"IntegerVariable","lib::variables","",6,null],[12,"name","lib::variables::LpExpression","",6,null],[12,"lower_bound","","",6,null],[12,"upper_bound","","",6,null],[13,"ContinuousVariable","lib::variables","",6,null],[12,"name","lib::variables::LpExpression","",6,null],[12,"lower_bound","","",6,null],[12,"upper_bound","","",6,null],[13,"MulExpr","lib::variables","",6,null],[13,"AddExpr","","",6,null],[13,"SubExpr","","",6,null],[13,"LitVal","","",6,null],[13,"EmptyExpr","","",6,null],[4,"Constraint","","",null,null],[13,"GreaterOrEqual","","",7,null],[13,"LessOrEqual","","",7,null],[13,"Equal","","",7,null],[5,"lp_sum","","make a complete expression or a constraint with a vector of expressions",null,{"inputs":[{"name":"vec"}],"output":{"name":"lpexpression"}}],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"new","","",8,{"inputs":[{"name":"s"},{"name":"lptype"}],"output":{"name":"lpexpression"}}],[11,"generalize","","",4,null],[11,"lower_bound","","",6,null],[11,"upper_bound","","",6,null],[0,"operations","lib","",null,null],[8,"LpOperations","lib::operations","Operations trait for any type implementing Into&lt;LpExpressions&gt; trait",null,null],[10,"le","","Less or equal binary syntax for LpExpression",9,null],[10,"ge","","Greater or equal binary syntax for LpExpression",9,null],[10,"equal","","Equality binary syntax for LpExpression",9,null],[11,"add","lib::variables","",6,null],[11,"sub","","",6,null],[11,"to_string","","",6,null]],"paths":[[4,"LpObjective"],[3,"LpProblem"],[4,"Solver"],[4,"Status"],[3,"LpConstraint"],[4,"LpType"],[4,"LpExpression"],[4,"Constraint"],[3,"LpVariable"],[8,"LpOperations"]]};
initSearch(searchIndex);
