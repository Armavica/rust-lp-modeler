var searchIndex = {};
searchIndex["lib"] = {"doc":"","items":[[0,"problem","lib","",null,null],[3,"LpProblem","lib::problem","Structure used for creating the model and solving a linear problem.",null,null],[4,"LpObjective","","Enum helping to specify the objective function of the linear problem.",null,null],[13,"Minimize","","",0,null],[13,"Maximize","","",0,null],[4,"Solver","","",null,null],[13,"Cbc","","",1,null],[13,"CbcPath","","",1,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",2,null],[11,"new","","Create a new problem",2,{"inputs":[{"name":"str"},{"name":"lpobjective"}],"output":{"name":"lpproblem"}}],[11,"write_lp","","",2,null],[11,"solve","","Solve the LP model",2,null],[11,"add_assign","","",2,null],[11,"add_assign","","",2,null],[0,"variables","lib","",null,null],[3,"LpVariable","lib::variables","",null,null],[3,"LpConstraint","","",null,null],[12,"0","","",3,null],[12,"1","","",3,null],[12,"2","","",3,null],[4,"LpType","","Type of variables. Using to initialize a linear programming variable",null,null],[13,"Binary","","Binary variable",4,null],[13,"Integer","","Integer variable",4,null],[13,"Continuous","","Reel variable",4,null],[4,"LpExpression","","ADT for Linear Programming Expression",null,null],[13,"BinaryVariable","","",5,null],[12,"name","lib::variables::LpExpression","",5,null],[13,"IntegerVariable","lib::variables","",5,null],[12,"name","lib::variables::LpExpression","",5,null],[12,"lower_bound","","",5,null],[12,"upper_bound","","",5,null],[13,"ContinuousVariable","lib::variables","",5,null],[12,"name","lib::variables::LpExpression","",5,null],[12,"lower_bound","","",5,null],[12,"upper_bound","","",5,null],[13,"MulExpr","lib::variables","",5,null],[13,"AddExpr","","",5,null],[13,"SubExpr","","",5,null],[13,"LitVal","","",5,null],[13,"EmptyExpr","","",5,null],[4,"Constraint","","",null,null],[13,"GreaterOrEqual","","",6,null],[13,"LessOrEqual","","",6,null],[13,"Equal","","",6,null],[5,"lp_sum","","make a complete expression or a constraint with a vector of expressions",null,{"inputs":[{"name":"vec"}],"output":{"name":"lpexpression"}}],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"new","","",7,{"inputs":[{"name":"s"},{"name":"lptype"}],"output":{"name":"lpexpression"}}],[11,"generalize","","",3,null],[11,"lower_bound","","",5,null],[11,"upper_bound","","",5,null],[0,"operations","lib","",null,null],[8,"LpOperations","lib::operations","Operations trait for any type implementing Into&lt;LpExpressions&gt; trait",null,null],[10,"le","","Less or equal binary syntax for LpExpression",8,null],[10,"ge","","Greater or equal binary syntax for LpExpression",8,null],[10,"equal","","Equality binary syntax for LpExpression",8,null],[11,"add","lib::variables","",5,null],[11,"sub","","",5,null],[11,"to_string","","",5,null]],"paths":[[4,"LpObjective"],[4,"Solver"],[3,"LpProblem"],[3,"LpConstraint"],[4,"LpType"],[4,"LpExpression"],[4,"Constraint"],[3,"LpVariable"],[8,"LpOperations"]]};
initSearch(searchIndex);
